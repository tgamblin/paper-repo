\section{Performance Results}
\EncodingPerfPlot{}
\SplicePerfPlot{}
\ScalingPerfPlot{}
We have fully implemented automatic splicing in Spack's concretizer and aim to
answer 4 questions about its performance:
\begin{questions}
\item Do the changes to the encoding of prebuilt packages in the concretizer
  introduce bugs or performance regressions? \label{rq:dev-regressions}
\item Does the concretizer produce spliced solutions when
  necessary? \label{rq:splice-correctness}
\item What is the overhead of considering spliced
  solutions? \label{rq:splice-performance}
\item How does automatic splicing performance scale in relation to the number of
  candidate splices? \label{rq:splice-scaling}
\end{questions}

\subsection{Experimental Setup}
\subsubsection{System Setup}
All performances runs were executed on a single node with 96 Intel Xenon Gold
6342 (Icelake) processors and 1TB of memory running Ubuntu 22.04.

\subsubsection{The RADIUSS stack and the mpiabi mock package}
In each of our experiments we consider the concretization of specs from the
RADIUSS software stack. RADIUSS is an open-source collection of HPC
infrastructure (\eg{} \package{Flux} and \package{LvArray}), portability tools
(\eg{} \package{RAJA} and \package{CHAI}), data management and visualization
(\eg{} \package{glvis} and \package{hatchet}), and simulation applications
(\eg{} \package{ascent} and \package{sundials}) created by LLNL in order to
provide a unified foundation for developing HPC applications.  Concretizing
RADIUSS packages is a common use-case for Spack and the packages vary in both
overall dependency structure and number of dependencies. Furthermore, many of
the packages in the RADIUSS stack have a virtual dependency on MPI which serves
as our splice target. For a splice candidate, we created a mock package,
\package{mpiabi}, based on \package{mvapich}, with a single version and the
ability to splice into \spec{mpich@3.4.3}. In \cref{sec:scaling}, we introduce
many copies of this package in order to assess the scaling factor of the number
of splice candidates.

\subsubsection{The local and public buildcaches}
Splicing requires the existence of pre-concretized specs so we use
\textit{buildcaches} of specs.  Buildcaches are Spack's way of providing
reusable binaries of prebuilt specs that map concrete specs to their build
targets (\eg{} shared libraries, executables, \etc{}) and whose contents can be
reasoned about by the concretizer when deciding which specs can be reused. Our
experiments rely on a local and a public buildcache. The local buildcache
consists of only specs from the RADIUSS stack (and transitive dependencies),
allowing us to construct a controlled environment to evaluate the correctness of
our implementation, containing \textasciitilde{}200 specs. The public buildcache, which is
generated by Spack \footnote{www.cache.spack.io} as a continuous integration
task, contains over 20,000 prebuilt specs that include multiple configurations
of the RADIUSS stack, which provides a use-case more in line with that of
the average Spack user.

\subsubsection{Concretization Objectives and Configurations}
We consider the concretization of each of the 32 individual specs in the RADIUSS
stack and there are three axes for configuration in our experiments. The first
axis is the version of Spack under consideration. We compare our implementation,
hence \splicespack{}, to the last commit on the main Spack Github repository
prior to the introduction of automatic splicing, hence
\oldspack{}. \footnote{Git commit hash for \oldspack{}:
  ad518d975c711c04bdc013363d8fc33a212e9194, git commit hash for \splicespack{}:
  9f7cff1780d1e3e97cf957d686966a74d3840af6. Spack code is available at
  \url{https://github.com/spack/spack}}. The second axis is the number of
reusable specs the concretizer considers when producing solutions. This can be
either the local RADIUSS buildcache or the public buildcache. The third axis is
whether automatic splicing is enabled when testing that implementation. Recall
from \cref{sec:implementation} that \splicespack{} allows for users to
conditionally enable the concretizer to consider automatic splices; however,
disabling automatic splicing \textit{does not} revert to the previous encoding
of reusable specs. Therefore, experiments where the feature is disabled are to
evaluate the performance of the new encoding of reusable specs without the added
expressivity of allowing splicing. Enabling splicing allows the concretizer to
consider solutions that involve splicing, but does not explicitly constrain it
to only consider solutions with splicing. In order to address the variability
inherent in heuristic nature of Spack's dependency resolution engine, we
evaluate each concretization objective in each configuration 30 times.

\subsection{Determining the Impact of the Changed Encoding for Reusable Specs}
\label{sec:encoding-exp}
In order to answer \ref{rq:dev-regressions}, we consider whether our
changes to the encoding of reusable specs and strategy for reuse
introduce regressions into the concretizer.  To accomplish this, we concretize
each objective using both \oldspack{} and \splicespack{} against both
buildcache configurations. We consider only the case where the automatic
splicing feature is disabled, such that the only difference between the two
implementations is the encoding of reusable specs.
\par
\Cref{fig:encoding-perf} shows the distribution over 30 runs
for concretizing the entire RADIUSS stack in the four possible
configurations. Across all specs in the RADIUSS stack, we see an
\enclocalincrease{} percent increase in average concretization time with access
to the local buildcache from our encoding change, and a \encremoteincrease{}
percent increase with access to the public buildcache. Therefore, we can see
that the change to the encoding of resuseable specs only introduces neglible
overhead into the performance of the concretizer.

\subsection{Evaluating the Correctness and Performance of Automatic Splicing}
\label{sec:corr-perf-exps}
In order to answer \ref{rq:splice-correctness} and \ref{rq:splice-performance},
we consider the subset of specs in RADIUSS that have a virtual dependency on
MPI. We concretize these MPI-dependent specs separately and jointly with an
explicit dependency on either \spec{mpich} in the case of \oldspack{}, or our
mock MPI package (\spec{mpiabi}) in the case of \splicespack{} using both
buildcache configurations. We ensure that \splicespack{} produces spliced
solutions when possible. We also include \spec{py-shroud} in order to evaluate
the overhead of enabling splicing on specs which cannot be spliced. Note that
\splicespack{} is solving a harder problem than \oldspack{}, since it now must
consider splicing rather than simple reuse, and thus one should expect a
increase in concretization time.

\Cref{fig:splice-perf} shows the distribution over 30 runs for
concretizing \spec{py-shroud} and the MPI-dependent specs in the RADIUSS stack
in the four possible configurations. Across all MPI-dependent specs in the
RADIUSS stack, we see a \splicelocalincrease{} percent increase in
concretization time with access to the local buildcache from our encoding
change, and a \spliceremoteincrease{} percent increase with access to the public
buildcache. We see virtually no difference in concretization time for
\spec{py-shroud} from our extension. Recall that the public buildcache is
roughly 2 orders of magnitude larger than the local buildcace (\textasciitilde{}200 specs
vs. \textasciitilde{}20,000 specs).

Thus, while enabling splicing introduces a potentially two minute increase to
concretization time in the case of specs like \spec{visit} and \spec{glvis}
against the large public buildcache, every spliced solution could save potential
hours of time spent building software. Furthermore, since splicing can be
conditionally enabled, users can easily opt out if they would not benefit from
splicing and would prefer faster concretization.
 
\subsection{Scaling the Number of Spliceable Packages}
\label{sec:scaling}
The previous experiments consider splicing a single package
with a single \directive{can\_splice} directive targeting \spec{mpich@3.4.3};
however, in more realistic scenarios there may be many potential splice
candidates for a given target. Therefore, in order to answer
\ref{rq:splice-scaling}, we will consider the same concretization goals as
\cref{sec:corr-perf-exps}, but instead of varying the version of Spack, we will
instead scale the number of potential splice candidates. We accomplish this by
first creating 100 of copies of \spec{mpiabi} differing only in name. We then
concretize with the same objectives as the previous experiment using only the
local buildcache while giving the concretizer access to increasingly large
subsets of the 100 mock packages. We also require that concretized specs
\emph{do not} depend on \spec{mpich}, but do not constrain which of the replicas
the concretizer chooses.

\Cref{fig:splice-scaling} shows how the average concretization time scales for
concretization of the RADIUSS stack. Across all MPI-dependent packages, the
average percent increase in concretization time between 10 and 100 replicas is
\scalingpercentincrease{}. Again, this increase on the order of minutes is
inconsequential compared the potential hours saved by not having to rebuild
packages. Note that there is very little overhead in scaling the number of
replicas for specs which do not have an MPI dependency.


